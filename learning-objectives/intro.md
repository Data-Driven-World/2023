---
sidebar_position: 0
---

import CollapsibleAnswer from '@site/src/components/CollapsibleAnswer';
import DeepDive from '@site/src/components/DeepDive';
import ImageCard from '@site/src/components/ImageCard';
import ChatBaseBubble from "@site/src/components/ChatBaseBubble";

# Learning Objectives

## Week 1: Sorting Algorithms

#### [Concept Map](/learning-objectives/python)

By the end of these lessons, students should be able to:

- Apply Python's **procedural** programming and **basic** data structures
- **Define** and **call** functions
- describe **bubble sort** and **insertion sort** algorithm and ways to optimise it.
- Implement Bubble sort and Insertion sort algorithms to **sort** a sequence of number
- Use **print** statements to debug code

## Week 2: Analysing Programs

#### [Concept Map](/learning-objectives/analysing-programs)

By the end of these lessons, students should be able to:

- Implement **binary heap** using Python's built-in list
- Describe **heap property**
- Describe the steps to **build heap**
- Implement algorithm to restore **heap property**
- Write functions to do **binary heap** data structure operation
- Implement **heapsort** using iteration
- Define **Big-O** notation and other asymptotic notations
- Derive **complexity** of a code using its computation model
- Create **plots** from array data for **visualising** computational time
- **Measure** computation time for bubble sort, insertion sort and heapsort

## Week 3: Divide and Conquer

#### [Concept Map](/learning-objectives/divide-conquer)

By the end of these lessons, students should be able to:

- Solve problems using **recursion**
- Identify problems that has recursive solutions
- Identify base case and recursive case in a recursive problem and its solution
- Explain and implement the recursive solution of Tower of Hanoi
- Explain and implement **merge sort** algorithm
- Derive solution for **recurrence** of tower of hanoi and merge sort using recursion-tree method
- Measure computation time of merge sort and **compare** it with the other sort algorithms
- Use helper function for a recursive solution
- Compare recursive solution with that using iteration and discuss its advantages and disadvantages

## Week 4: Object-Oriented Paradigm

#### [Concept Map](/learning-objectives/oop)

By the end of these lessons, students should be able to:

- Use object-oriented programming to abstract data 
- Create `class` definitions with initialization and other methods
- Create **stored** property and **computed** property
- Draw UML class diagram of a class with attributes and methods
- Explain `has-a` relationship
- Use object-oriented programming to implement computation
- Discuss object **aliasing** and **copying**
- Draw UML class diagram for `has-a` relationship
- Implement abstract data type for **Stack**, **Queue** using Object Oriented paradigm
- Implement Queue using double **Stack** and discuss implementation **impact** on computation time


## Week 5: Inheritance and Intro to Graph

#### [Concept Map](/learning-objectives/inheritance-graph)

By the end of these lessons, students should be able to:
- **Apply** Stack and Queue for some applications
- Inherit a class to create a **child** class
- Explain `is-a` relationship
- Draw **UML** diagram for `is-a` relationship
- **Override** operators to extend parent's methods
- Use **Dictionary** and **OOP** to represent graph
- Define **graph**, **vertices**, **edges** and **weights**
- Differentiate **directed** and **undirected** graphs
- Define **paths**
- Create a `Vertex` class and a `Graph` class
- Represent graphs using **adjacency-list** representation or **adjacency-matrix** representation
- Extend class **Vertex** and **Graph** for graph traversal algorithm

## Week 6: Graph Traversal

#### [Concept Map](/learning-objectives/graph-traversal)
By the end of these lessons, students should be able to:
- Explain and implement **breadth** first search 
- Explain and implement **depth** first search


## Week 8: Visualizing and Processing Data

#### [Concept Map](/learning-objectives/vis-proc)

By the end of these lessons, students should be able to:

- Give example of **linear regression and classification**
- Create a **Panda's DataFrame** and selecting data from DataFrame
- Convert Panda's DataFrame to Numpy Array
- Selecting data from Numpy Array
- Using Panda's library to read `CSV` file
- **Split** data randomly into training set and testing set
- **Normalize** data using z-normalization and min-max normalization
- Create **scatter** plot and statistical plots like box plot, histogram, and bar plot

## Week 9: Modelling Continuous Data

#### [Concept Map](/learning-objectives/modelling)

By the end of these lessons, students should be able to:

- Write **cost** function of linear regression
- Implement **Gradient Descent algorithm** for optimisation
- Train **linear regression model** using gradient descent
- Transform data for **polynomial** model
- Evaluate linear regression model using `r^2` and mean-squared-error
- Evaluate and choose **learning rate**
- Plot **cost** function over iteration time
- Plot **linear** regression

## Week 10: Classifying Categorical Data

#### [Concept Map](/learning-objectives/classify)

By the end of these lessons, students should be able to:

- Write **cost** function of **logistic** regression
- Use logistic regression to **calculate** probabilities of binary classification
- Train **logistic** regression model
- Split data into **training**, **validation**, and **testing** set
- Classify **multi-class** problems using one-vs-all technique
- Calculate **confusion** **matrix**, **precision**, and **recall**.

## Week 12: Design of State Machines

#### [Concept Map](/learning-objectives/sm)

By the end of these lessons, students should be able to:

- Define a **state machine**
- Implement an **Abstract Base Class** for State Machine using abc module
- Define **output** function and **next** state function
- Draw **state transition diagram** and **time-step table**
- **Implement** output function and next state function inside `get_next_values` overridden method.
- **Apply** breadth first search to perform state-space search
