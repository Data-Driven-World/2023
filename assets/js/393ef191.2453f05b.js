"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[4125],{6506:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>b,frontMatter:()=>o,metadata:()=>m,toc:()=>c});var n=a(7462),s=a(7294),i=a(3905),r=(a(1694),a(3707),a(6533),a(505));const o={sidebar_position:3},l="Abstract Base Class",m={unversionedId:"inheritance-graph/abc",id:"inheritance-graph/abc",title:"Abstract Base Class",description:"This topic is optional and no longer included in the syllabus.",source:"@site/docs/05-inheritance-graph/abc.md",sourceDirName:"05-inheritance-graph",slug:"/inheritance-graph/abc",permalink:"/2023/notes/inheritance-graph/abc",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Basics of Graph",permalink:"/2023/notes/inheritance-graph/basics-graph"},next:{title:"Fixed-Size Array and Linked List",permalink:"/2023/notes/inheritance-graph/array-linkedlist"}},p={},c=[{value:"Goals",id:"goals",level:3},{value:"Abstract Base Class for Creating Abstract Data Types",id:"abstract-base-class-for-creating-abstract-data-types",level:2}],h={toc:c},d="wrapper";function b(e){let{components:t,...a}=e;return(0,i.kt)(d,(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"abstract-base-class"},"Abstract Base Class"),(0,i.kt)(r.Z,{mdxType:"ChatBaseBubble"}),(0,i.kt)("p",null,"This topic is optional and no longer included in the syllabus. "),(0,i.kt)("h3",{id:"goals"},"Goals"),(0,i.kt)("p",null,"By the end of this lesson, you should be able to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"state the purpose of Abstract Base Class"),(0,i.kt)("li",{parentName:"ul"},"define Abstract Base Class")),(0,i.kt)("admonition",{title:"Keywords",type:"keyword"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"abstract base class"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"iterable"))),(0,i.kt)("p",null,"There are cases when the ",(0,i.kt)("em",{parentName:"p"},"parent")," class only specifies what attributes and methods the child classes should have and in itself contain no implementation. You can think of this as something like the following definition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MyAbstractClass:\n    def add(self, other):\n        pass\n\nclass ChildOfMyAbstractClass(MyAbstractClass):\n    def add(self, other):\n        # contains implementation of adding the two objects\n        ...\n")),(0,i.kt)("p",null,"In the first class of ",(0,i.kt)("inlineCode",{parentName:"p"},"MyAbstractClass"),", there is a method ",(0,i.kt)("inlineCode",{parentName:"p"},"add(other)")," which contains no definition. This method is overriden by the child class ",(0,i.kt)("inlineCode",{parentName:"p"},"ChildOfMyAbstractClass"),". In this class, ",(0,i.kt)("inlineCode",{parentName:"p"},"add(other)")," is defined and, thus, overridden."),(0,i.kt)("p",null,"Previously in ",(0,i.kt)("inlineCode",{parentName:"p"},"MixedFraction")," class, we see how the child class' operations depends on the implementation of its parent class' methods. In that case, no ",(0,i.kt)("inlineCode",{parentName:"p"},"__add__()")," nor ",(0,i.kt)("inlineCode",{parentName:"p"},"__sub__()")," is defined in the child class. Therefore any method call to do addition and subtraction will be referred to the parent class implementation. The case of an Abstract class is the opposite of this. When we have an Abstract class with no implementation, we are forcing the implementation to be found in the child class. However, by writing the code as shown above, there is nothing that prevents the child class ",(0,i.kt)("strong",{parentName:"p"},"not")," to implement the required method."),(0,i.kt)("p",null,"Python provides some mechanism to ensure that the abstract method in the abstract base class is implemented in the child class. Let's take a look at one example of this using ",(0,i.kt)("inlineCode",{parentName:"p"},"collections.abc")," class. This ",(0,i.kt)("inlineCode",{parentName:"p"},"collections.abc")," class is an Abstract Base Class for containers. For example, if we want to create a new data type belonging to a type ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterable"),", we can inherit this new class from ",(0,i.kt)("inlineCode",{parentName:"p"},"collections.abc.Iterable"),". Python will force the new class to define the method ",(0,i.kt)("inlineCode",{parentName:"p"},"__iter__()"),". Otherwise, Python will throw an error. Let's try it out in the next cell."),(0,i.kt)(s.Fragment,null,(0,i.kt)("iframe",{src:"https://trinket.io/embed/python3/ab78c95e4f?start=result",width:"100%",height:"350",frameborder:"0",marginwidth:"0",marginheight:"0",allowfullscreen:!0})),(0,i.kt)("p",null,"When you run the above cell, Python will complain saying that it cannot instantiate the new class because we did not implement the abstract method ",(0,i.kt)("inlineCode",{parentName:"p"},"__iter__()"),". To fix this, we need to define this method in the child class."),(0,i.kt)(s.Fragment,null,(0,i.kt)("iframe",{src:"https://trinket.io/embed/python3/80d189528e?start=result",width:"100%",height:"350",frameborder:"0",marginwidth:"0",marginheight:"0",allowfullscreen:!0})),(0,i.kt)("p",null,"There will be no error when you run the above cell because now the method ",(0,i.kt)("inlineCode",{parentName:"p"},"__iter__()")," has been implemented in the child class. The definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"__iter__()")," simply returns an iterable object from ",(0,i.kt)("inlineCode",{parentName:"p"},"self.data"),"."),(0,i.kt)("p",null,"So, we have shown the mechanism where Python ensures that when you create an Abstract Base Class with some abstract methods, the child class must implement this abstract method. Otherwise, Python will throw an exception. In future lessons, we will create our own Abstract Base Class."),(0,i.kt)("h2",{id:"abstract-base-class-for-creating-abstract-data-types"},"Abstract Base Class for Creating Abstract Data Types"),(0,i.kt)("p",null,"We can apply this concept of Abstract Base Class to implement Abstract Data Type (ADT). ADT is a data type for objects whose behaviour is defined by some specific interface. The interface defines the operations that the data type can perform. However, ADT does not define how these operations are to be ",(0,i.kt)("em",{parentName:"p"},"implemented"),". It is called ",(0,i.kt)("em",{parentName:"p"},"abstract")," because it is independent of its implementation."),(0,i.kt)("p",null,"As an example, we can create an Abstract Data Type (ADT) for a List object. In this list object, we can specify a set of operation as its interface. This operations specifies what List ADT can do. For example, here are some common List operations we can think of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a List object an ",(0,i.kt)("em",{parentName:"li"},"access")," an element in the list using its index."),(0,i.kt)("li",{parentName:"ul"},"a List object can ",(0,i.kt)("em",{parentName:"li"},"modify")," an element in the list given its index."),(0,i.kt)("li",{parentName:"ul"},"a List object can ",(0,i.kt)("em",{parentName:"li"},"append")," an element into the list."),(0,i.kt)("li",{parentName:"ul"},"a List object can ",(0,i.kt)("em",{parentName:"li"},"remove")," an element given its index position."),(0,i.kt)("li",{parentName:"ul"},"a List object can ",(0,i.kt)("em",{parentName:"li"},"check the number")," of elements in the list.")),(0,i.kt)("p",null,"As mentioned previously, ADT does not specify how to implement these operations nor how to implement the data structure underlying it. ADT only specifies its interface by stating what are the operations that this data type should be able to do. Why is this important? The reason is that certain implementation may be better for specific scenario while other implementation maybe be better for other scenario."),(0,i.kt)("p",null,"Let's give some example to this. Let's imagine if our List ADT is implemented using Python's built-in list. We know from Python computational model that the following holds true for the complexity of the following operations."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"append(item)")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"pop()")," has complexity of ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"O"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mn",{parentName:"mrow"},"1"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(1)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord"},"1"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")"))))),"."),(0,i.kt)("li",{parentName:"ul"},"on the other hand, ",(0,i.kt)("inlineCode",{parentName:"li"},"insert(0, item)")," has complexity of ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"O"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mi",{parentName:"mrow"},"n"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")"))))),".")),(0,i.kt)("p",null,"Imagine if our use case has more operations to insert at the beginning of the List. In this case, Python's built-in list may not be the best implementation. Another implementation like Linked List maybe better. We will discuss about Linked List in the next section. But for now, we see that different implementation may have different performance. However, the operations for List remain the same. Regardless of how it is implementated, we still want to insert the item or remove it."),(0,i.kt)("p",null,"Therefore, it is useful to define an Abstract Base Class that specifies the interface of an Abstract Data Type. In our case, we can define that a List must have some specific operations that it has to support such as appending, inserting and removing elements. The Abstract Base Class may not have the full implementation and yet it specifies that it request some of these ",(0,i.kt)("em",{parentName:"p"},"methods")," to be implemented in the child class."),(0,i.kt)("p",null,"We can then design an abstract base class for our List data as shown in the image below."),(0,i.kt)("br",null),(0,i.kt)("mermaid",{value:"classDiagram\n    class MyAbstractList\n    <<Abstract>> MyAbstractList\n    MyAbstractList <|.. MyPythonList : implements\n    MyAbstractList <|.. MyArrayList  : implements\n    MyAbstractList <|.. MyLinkedList  : implements"}),(0,i.kt)("br",null),(0,i.kt)("p",null,"In this design, we have one abstract base class called ",(0,i.kt)("inlineCode",{parentName:"p"},"MyAbstractList")," which defines the interface for our List ADT. This base class can be implemented in many ways. In your problem sets, you will implement this List ADT using a Fixed Size Array (",(0,i.kt)("inlineCode",{parentName:"p"},"MyArrayList"),") as well as using a Linked List (",(0,i.kt)("inlineCode",{parentName:"p"},"MyLinkedList"),"). Details on the Fixed Size Array and Linked List is given in the next section. We gave you the implementation the List ADT using Python's built-in List (",(0,i.kt)("inlineCode",{parentName:"p"},"MyPythonList"),") in the problem set."),(0,i.kt)("p",null,"The great thing is that all these three different implementation has a common interface and a same set of methods. This way, you can switch your List implementation and the rest of the code still works fine because it follows the common interface of our ",(0,i.kt)("inlineCode",{parentName:"p"},"MyAbstractList")," ADT. In this case, our abstract base class ",(0,i.kt)("inlineCode",{parentName:"p"},"MyAbstractList")," enforces that the child class has to implement some specific methods. Extending this concept further, we can actually inherit ",(0,i.kt)("inlineCode",{parentName:"p"},"MyAbstractList")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"collections.abc.Iterator"),". In this way, we enforce that our List ADT must have the ",(0,i.kt)("inlineCode",{parentName:"p"},"__iter__()")," method. This allows our List ADT to be iterated over each of its elements. We can draw the final UML diagram in this way."),(0,i.kt)("br",null),(0,i.kt)("mermaid",{value:"classDiagram\n    class MyAbstractList\n    <<Abstract>> MyAbstractList\n    class `collections.abc.iterator`\n    <<Abstract>> `collections.abc.iterator`\n    MyAbstractList <|.. MyPythonList : implements \n    MyAbstractList <|.. MyArrayList  : implements\n    MyAbstractList <|.. MyLinkedList  : implements\n    `collections.abc.iterator` <|.. MyAbstractList : implements"}))}b.isMDXComponent=!0}}]);